青蛙过河 :star::star::star:
=
题目
-
一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。<br>
给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。<br>
如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。<br>
#### Example 1
    [0,1,3,5,6,8,12,17]

    总共有8个石子。
    第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,
    第三个石子在序号为3的单元格的位置， 以此定义整个数组...
    最后一个石子处于序号为17的单元格的位置。

    返回 true。即青蛙可以成功过河，按照如下方案跳跃： 
    跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 
    跳2个单位到第4块石子, 然后跳3个单位到第6块石子, 
    跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。

#### Example 2
    [0,1,2,3,4,8,9,11]

    返回 false。青蛙没有办法过河。 
    这是因为第5和第6个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。
题解
-
最后一步：如果可以调到最后一个石头an-1，考虑最后跳的一步L，青蛙一定是从ai = an-1 - j  跳过来<br>
所以考虑是否能调到ai，并且倒数第二跳只能是L-1，L，L+1
设上一块石头是ak = ai - j，可以通过一个哈希表(ak -> k)快速找到k
<br>

    设f[i][j]表示是否能最后一跳长度j跳到石头ai
    f[i][j] = f[k][j-1] or f[k][j+1] or f[k][j+1]| ak = ai - j
<br>
也可以反过来想，如果已知f[k][j] = True，即可以最后一跳j到达石头ak，则可以调到ak+j-i， ak+j，ak+j+1，如果那里恰好有石头的话<br>
用一个集合si来保存能跳到一个石头ai的可能的最后一跳<br>
枚举每一个在集合Si中的L，从石头i尝试往后跳L-1,L和L+1<br>
如果跳了M举例之后有一个石头j，则把M加到Sj中，表示可以最后一步跳M到达石头j<br>


















来源：力扣（LeetCode）
